package testTSPGA;

import java.awt.Point;
import java.util.Vector;

import javax.swing.SwingWorker;

import org.jgap.Configuration;
import org.jgap.IChromosome;

import geneticAlgorithms.TSP_GA;

public class TSP_GA_Adapter {
	private TSP_GA tsp;
	
	private TSP_GA_Worker tspWorker;
	private IChromosome bestPath;
	private Vector<Point> points;
	private Configuration config;
	private Vector<Vector<Point>> resultsData;
	
	public TSP_GA_Adapter(TSP_GA_Worker fw, Vector<Point> cities, Configuration c, Vector<Vector<Point>> results){
		tspWorker=fw;
		//resultsData=tspGaRef.results;
		//tsp=tspGaRef;
		points=cities;
		config=c;
		resultsData=results;
	}

	protected Object doInBackground(){
		//tsp=new TSP_GA(null,null,null);
		//tsp.startExecution(tsp);
		try {
			/*Configuration conf = new Configuration();
			Vector<Point> data= new Vector<Point>();
			data.add(new Point(2,4)); 
			data.add(new Point(7,5)); 
			data.add(new Point(7,11)); 
			data.add(new Point(8,1)); 
			data.add(new Point(5,9)); 
			data.add(new Point(0,11)); 
			data.add(new Point(1,6));
			data.add(new Point(2,7)); 
			data.add(new Point(9,9)); 
			data.add(new Point(0,8));
			
			data.add(new Point(2232,43)); 
			data.add(new Point(23,45)); 
			data.add(new Point(45,21));
			data.add(new Point(35,11232)); 
			data.add(new Point(68,41235)); 
			data.add(new Point(11233,46));
			data.add(new Point(56,23)); 
			data.add(new Point(21233,65)); 
			data.add(new Point(45,12));
			//Setup the Configuration
			conf.setKeepPopulationSizeConstant(false);
			conf.setMinimumPopSizePercent(2);
			conf.setPopulationSize(data.size());
			//Specify the type of Crossover method
			//conf.addGeneticOperator(new CycleCrossover(conf));
			//Specify the type of Mutation method
			//conf.addGeneticOperator(a_operatorToAdd);
			//Initialize the process and Start the evolution*/
			tsp= new TSP_GA(points,config,this,resultsData);
			if(points!=null && config!=null && resultsData!=null){
				bestPath = tsp.findOptimalPath(null);
			}
			else{
				System.out.println("Error, values are null");
			}
			//Set a maximum number of interactions
			//tsp.setMaxEvolution(100);
			//bestPath = tsp.findOptimalPath(null);
			//bestPath=tsp.getBestPath();
			//System.out.println("Solution: ");
			//System.out.println(optimal);
			//System.out.println("Score " + (Integer.MAX_VALUE / 2 - optimal.getFitnessValue()));
			//updateProgress(100, bestPath);
			//tsp.notifyAll();
		}
		catch (Exception ex) {
			ex.printStackTrace();
		}
		
		return null;
	}
	
	public void updateProgress(int value){
		tspWorker.updateProgress(value);
		//this.setProgress(value);
		//System.out.println("Updated!");
	}

}
